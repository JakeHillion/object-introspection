[info]
typeName = "std::variant"
ctype = "STD_VARIANT_TYPE"
header = "variant"
ns = ["namespace std"]

[codegen]
decl = """
template <typename DB, typename... Types>
struct TypeHandler<DB, %1%<Types...>> {
    using type = StaticTypes::Sum<DB, typename TypeHandler<DB, Types>::type..., StaticTypes::Unit<DB>>;

    static StaticTypes::Unit<DB> getSizeType(
        const %1%<Types...>& container,
        typename TypeHandler<DB, %1%<Types...>>::type returnArg) {
      return getSizeTypeRecursive(container, returnArg);
    }

  private:
    template <size_t I = 0>
    static StaticTypes::Unit<DB> getSizeTypeRecursive(
        const %1%<Types...>& container,
        typename TypeHandler<DB, %1%<Types...>>::type returnArg) {
      if constexpr (I < sizeof...(Types)) {
        if (I == container.index()) {
          return returnArg.template delegate<I>([&container](auto ret) {
            return OIInternal::getSizeType<DB>(std::get<I>(container), ret);
          });
        } else {
          return getSizeTypeRecursive<I+1>(container, returnArg);
        }
      } else {
        return returnArg.template delegate<sizeof...(Types)>(std::identity());
      }
    }
};
"""

func = """
// DummyFunc %1%
"""
